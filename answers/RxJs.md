## <a name="observable-promise"></a>Что такое RxJS?

**RxJS (Reactive Extensions for JavaScript)** — это библиотека для реактивного программирования в JavaScript, основанная на концепции *Observable streams* (наблюдаемых потоков).  

Позволяет:

- работать с **асинхронными потоками данных**
- декларативно описывать трансформации
- управлять временем, отменой и конкуренцией
- композировать сложные сценарии асинхронного кода

RxJS реализует паттерн **Observable + Observer** и активно использует **функциональный подход** (`map`, `filter`, `reduce` и т.д.).

<br/>


## <a name="observable-promise"></a>Что такое поток (Stream)?

Поток — это **последовательность значений во времени**.  

Особенности:

- значения могут приходить синхронно или асинхронно
- поток может завершиться (`complete`)
- поток может завершиться с ошибкой (`error`)

Примеры потоков:

- события DOM
- ответы HTTP
- сообщения WebSocket
- изменения формы
- interval / таймер

<br/>

## <a name="observable-promise"></a>Что такое реактивное программирование?

Реактивное программирование — это парадигма, основанная на:

- работе с потоками данных
- реактивной обработке изменений
- декларативном описании зависимостей

Принцип:

> Вместо того чтобы запрашивать данные, мы **подписываемся на их изменения**.

Сдвиг от **pull-based (императивного)** к **push-based (реактивному)**.  

Reactive-код описывает *что должно произойти при изменении данных*, а не *когда и как вызывать функции вручную*.

<br/>


## <a name="observable-promise"></a>В чем разница между observable и promise?

**Promise**:

- возвращает только одно значение при завершении или ошибке
- не ленивый — начинается сразу
- нельзя отменить

**Observable**:

- может выдавать несколько значений со временем
- выполняется только после подписки
- можно отменить через `unsubscribe()`
- имеет полезные методы для работы с данными: `map`, `filter`, `reduce`, `retry`, `retryWhen` и др.

<br/>

## <a name="observable-subject"></a>В чем разница между Cold и Hot Observables?

**Cold Observable**:

- данные создаются внутри самого Observable
- значения начинают приходить **только после подписки**
- каждый подписчик получает свою копию данных

**Hot Observable**:

- данные создаются **вне Observable**
- значения могут приходить **даже до подписки**
- используется для **общих источников данных** (например, события кликов или WebSocket) для нескольких подписчиков

<br/>

## <a name="observable-subject"></a>Что такое Observers и Subscriptions?
**Observers (наблюдатели)**:

- это **слушатели данных** из Observable  
- они подписываются и реагируют на поступающие значения

**Subscriptions (подписки)**:

- объект, который возвращается после подписки на Observable
- позволяет **отменить подписку**, когда она больше не нужна

<br/>

## <a name="observable-subject"></a>Что такое Subject?
**Subject** — это особый тип Observable, который **отправляет данные сразу нескольким подписчикам** (multicast).  
Пример: один источник данных → несколько слушателей.

<br/>

## <a name="observable-subject"></a>Какие бывают типы Subject?
Существуют три основных типа:

### 1️⃣ Subject

- Не сохраняет значения до подписки  
- Новые подписчики **не получают старые данные**, только новые, которые будут выдаваться после подписки

---

### 2️⃣ BehaviorSubject

- Хранит **последнее значение**  
- При подписке новые наблюдатели **сразу получают последнее значение**, а потом продолжают получать новые

---

### 3️⃣ ReplaySubject

- Хранит **все значения** (или последние N значений, если указать буфер)  
- При подписке новые наблюдатели **получают все сохраненные значения**, а потом новые  
- Использует буфер для хранения значений и их повторной отправки новым подписчикам

<br/>

## <a name="observable-subject"></a>В чем разница между observable и subject?

В случае Observable каждая новая подписка (subscribe) получает новую копию данных.

```typescript
import { Observable } from "rxjs";

let obs = Observable.create((observer) => {
	observer.next(Math.random());
});

obs.subscribe((res) => {
	console.log("subscription a :", res); //subscription a :0.2859800202682865
});

obs.subscribe((res) => {
	console.log("subscription b :", res); //subscription b :0.694302021731573
});
```

<br/>

Когда мы используем Subject все подписчики получают одни и те же данные.

```typescript
import { Subject } from "rxjs";

let obs = new Subject();

obs.subscribe((res) => {
	console.log("subscription a :", res); // subscription a : 0.91767565496093
});

obs.subscribe((res) => {
	console.log("subscription b :", res); // subscription b : 0.91767565496093
});

obs.next(Math.random());
```

<br/>

## <a name="how-to-cache"></a>Что такое Scheduler в RxJS?
**Scheduler** управляет временем выполнения подписки и уведомлениями.  

Проще говоря, это **кто и когда будет запускать Observable**.  

Основные типы:

- `queueScheduler` – выполняет задачи **последовательно в очереди**.  
- `asapScheduler` – выполняет задачи **как можно скорее**, но после текущего кода.  
- `asyncScheduler` – выполняет задачи **асинхронно через setTimeout**.  
- `animationFrameScheduler` – выполняет задачи **в момент перерисовки экрана** (для анимаций).  

**Пример:**

```ts
import { of, asyncScheduler } from 'rxjs';
import { observeOn } from 'rxjs/operators';

of(1,2,3)
  .pipe(observeOn(asyncScheduler))
  .subscribe(x => console.log(x));

Здесь числа будут выведены асинхронно, после завершения текущего кода.
```
<br/>


## <a name="how-to-cache"></a>Как кэшировать данные из Observable?

Кэширование потоков позволяет **повторно использовать полученные данные**, не делая лишние HTTP-запросы или не пересоздавая поток заново для каждого подписчика.

### 1️⃣ Используем `shareReplay()`

- Объединяет функции `publishReplay()` и `refCount()`  
- Хранит последние N значений и отдаёт их новым подписчикам  
- Автоматически управляет подписками: если подписчиков нет, поток "отписывается"  

**Пример кэширования HTTP-запроса:**

```ts
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { shareReplay } from 'rxjs/operators';

class BookService {
  constructor(private http: HttpClient) {}

  private books$: Observable<Books[]>;

  getBooks(): Observable<Books[]> {
    if (!this.books$) {
      this.books$ = this.http.get<Books[]>('/api/books')
        .pipe(
          shareReplay(1) // кэшируем последнее значение для новых подписчиков
        );
    }
    return this.books$;
  }
}
```
Первый подписчик запускает HTTP-запрос, а последующие подписчики сразу получают кэшированные данные без нового запроса.

2️⃣ Используем BehaviorSubject

Хранит текущее значение<br/>
Позволяет сразу отдавать его новым подписчикам<br/>
Полезно, если нужно добавлять/обновлять данные вручную<br/>
```ts
import { BehaviorSubject } from 'rxjs';

// Инициализация с начальным значением
const theme$ = new BehaviorSubject<'light' | 'dark'>('light');

// Подписчик сразу получит 'light'
theme$.subscribe(console.log);

// Смена значения (все будущие подписчики получат уже 'dark')
theme$.next('dark');
```

<br/>

## <a name="order-api-calls"></a>Как с помощью rxjs реализовать несколько запросов к api, которые должны идти друг за другом?

# Как реализовать последовательные запросы к API в RxJS?

Для реализации запросов, которые должны идти строго друг за другом, используются **Observable высшего порядка** (Higher-Order Observables). Самым подходящим оператором для этой задачи является `concatMap`.

---

## 1. Оператор `concatMap` (Рекомендуемый способ)

`concatMap` гарантирует строгую последовательность: он подписывается на следующий внутренний Observable только после того, как предыдущий завершился (`complete`).

* **Как работает:** Если первый запрос еще выполняется, а пришло новое событие, `concatMap` поставит его в очередь.
* **Когда использовать:** Когда порядок выполнения критичен (например, создание записи, а затем получение её ID для загрузки картинки).

### Пример:
```typescript
import { from } from 'rxjs';
import { concatMap, delay } from 'rxjs/operators';
import { ajax } from 'rxjs/ajax';

const userIds = [1, 2, 3];

from(userIds).pipe(
  concatMap(id => {
    console.log(`Запрос данных для пользователя ${id}...`);
    return ajax.getJSON(`https://jsonplaceholder.typicode.com/users/${id}`);
  })
).subscribe(user => console.log('Получены данные:', user));
```

2. Обработка ошибок в цепочке
При последовательных запросах важно решить: должен ли сбой одного запроса остановить всю очередь?

Чтобы очередь не прерывалась: используйте catchError внутри concatMap.

```ts
from(userIds).pipe(
  concatMap(id => 
    ajax.getJSON(`/api/user/${id}`).pipe(
      catchError(error => {
        console.error(`Ошибка на ID ${id}:`, error.message);
        return of(null); // Продолжаем очередь, возвращая заглушку
      })
    )
  )
).subscribe();
```

### 3. Другие операторы (Альтернативы)

| Оператор | Поведение | Когда использовать |
| :--- | :--- | :--- |
| **`concatMap`** | Ждет завершения текущего и сохраняет очередь. | Строгая последовательность (заказы, транзакции). |
| **`switchMap`** | Отменяет текущий запрос, если пришел новый. | Живой поиск, навигация. |
| **`exhaustMap`** | Игнорирует новые события, пока текущий запрос не завершен. | Кнопки (защита от двойного клика). |
| **`mergeMap`** | Выполняет все запросы одновременно (параллельно). | Когда порядок не важен и нужна скорость. |

<br/>

## <a name="switchMap-concatMap-mergeMap"></a>В чем разница между switchMap, concatMap и mergeMap?

В RxJS эти операторы называются **операторами высшего порядка** (Flattening Operators). Они определяют, как основной поток должен обрабатывать новые события, если предыдущий внутренний поток (например, HTTP-запрос) еще не завершился.

---

### Сравнительная таблица операторов

| Оператор | Поведение (Стратегия) | Порядок выполнения | Когда использовать |
| :--- | :--- | :--- | :--- |
| **`switchMap`** | **Отмена**: Переключается на новый поток, убивая старый. | Последний "побеждает". | Поиск (Typeahead), навигация, фильтрация. |
| **`concatMap`** | **Очередь**: Ждет завершения текущего, прежде чем начать следующий. | Строгий порядок (FIFO). | Сохранение данных, транзакции, отправка сообщений. |
| **`mergeMap`** | **Параллелизм**: Запускает всё одновременно, не дожидаясь никого. | Хаотичный (кто быстрее ответит). | Загрузка нескольких независимых файлов. |
| **`exhaustMap`** | **Игнорирование**: Пока идет поток, новые события отбрасываются. | Первый "побеждает". | Кнопки "Оплатить" или "Загрузить" (защита от спама). |

---

### Подробный разбор

#### 1. `switchMap` (Переключение)
Подписывается на новый Observable и **сразу отменяет** подписку на предыдущий. В каждый момент времени активен только один поток.
* **Плюс:** Автоматическая очистка старых запросов, экономия ресурсов.
* **Минус:** Если сервер обрабатывает запрос медленно, вы можете не получить данные, если пришло новое событие.

#### 2. `concatMap` (Последовательность)
Ставит новые события в **очередь**. Он не подпишется на следующий Observable, пока текущий не вызовет `complete()`.
* **Плюс:** Гарантирует, что данные придут на сервер ровно в том порядке, в котором они были отправлены.
* **Минус:** Один зависший запрос заблокирует всю очередь ("пробка").

#### 3. `mergeMap` (Слияние)
Подписывается на все входящие Observable одновременно. Внутренние потоки живут своей жизнью параллельно.
* **Плюс:** Максимальная скорость выполнения задач.
* **Минус:** Порядок ответов непредсказуем. Большое количество одновременных запросов может перегрузить сеть или браузер.

---

### Практический пример (Концепт)

Представим клики по кнопке, каждый из которых запускает запрос на 2 секунды:

```typescript
import { fromEvent, interval } from 'rxjs';
import { switchMap, concatMap, mergeMap, take } from 'rxjs/operators';

const clicks$ = fromEvent(document, 'click');

// Пример: если кликнуть 3 раза быстро
clicks$.pipe(
  concatMap(() => interval(1000).pipe(take(2)))
).subscribe(val => console.log('Результат:', val));

// Результат concatMap: 0, 1 ... 0, 1 ... 0, 1 (всего 6 сек)
// Результат switchMap: (только последние 0, 1 после финального клика)
// Результат mergeMap: 0, 0, 0, 1, 1, 1 (все вперемешку, закончит за 2 сек)
```

<br/>

## <a name="scan-reduce"></a>В чем разница между scan() и reduce()?

Оба оператора используют функцию-аккумулятор для обработки входящих значений, но они ведут себя по-разному в отношении того, **когда** они выдают результат.

---

### Основное отличие

* **`scan`** — выдает накопленное значение **после каждого** события из источника. Это делает его идеальным для отслеживания состояния в реальном времени.
* **`reduce`** — выдает накопленное значение **только один раз**, когда входной поток полностью завершается (`complete`). Если поток бесконечен, `reduce` никогда не сработает.

---

### Современный пример кода (RxJS 7+)

В современных версиях RxJS мы используем функцию `of` для создания потока и метод `.pipe()` для применения операторов.

```typescript
import { of } from 'rxjs';
import { scan, reduce } from 'rxjs/operators';

const source$ = of(1, 2, 3, 4, 5, 6);

// SCAN: показывает промежуточные итоги (нарастающий итог)
source$.pipe(
  scan((acc, curr) => acc + curr, 0)
).subscribe(val => console.log('scan (промежуточно):', val));

// REDUCE: показывает только финальный результат
source$.pipe(
  reduce((acc, curr) => acc + curr, 0)
).subscribe(val => console.log('reduce (итого):', val));
```

//scan (промежуточно): 1
//scan (промежуточно): 3
//scan (промежуточно): 6
//scan (промежуточно): 10
//scan (промежуточно): 15
//scan (промежуточно): 21

//reduce (итого): 21

| Характеристика | `scan` | `reduce` |
| :--- | :--- | :--- |
| **Частота эмита** | На каждое входящее значение. | Один раз при завершении потока. |
| **Бесконечные потоки** | Работает отлично (например, клики). | **Не работает** (никогда не выдаст значение). |
| **Аналогия из JS** | Аналога в массивах нет (ближе к Redux). | Похож на стандартный `Array.prototype.reduce`. |
| **Основная цель** | Управление состоянием (State Management). | Агрегация данных в финальный результат. |

<br/>

## <a name="subject"></a>Что такое Subject?

**Subject** в RxJS — это особый тип Observable, который позволяет рассылать данные сразу множеству подписчиков. Если обычный Observable (unicast) подобен фильму на Netflix (каждый смотрит свою копию с начала), то Subject (multicast) подобен прямой трансляции (все зрители видят одно и то же одновременно).

---

### Ключевые особенности

1.  **Multicasting (Многоадресность)**: В отличие от обычных Observable, Subject хранит список подписчиков и уведомляет всех одновременно при поступлении новых данных.
2.  **Двойственная природа**:
    * **Как Observable**: На него можно подписаться, используя `.subscribe()`, и применять к нему любые операторы.
    * **Как Observer**: У него есть методы `.next()`, `.error()` и `.complete()`. Это позволяет "проталкивать" данные в поток вручную.
3.  **Hot Observable**: Subject является "горячим". Это означает, что он может начать эмитить данные еще до того, как на него кто-то подписался (и те, кто опоздал, пропустят эти данные).

---

### Пример использования

```typescript
import { Subject } from 'rxjs';

// Создаем экземпляр Subject
const mySubject$ = new Subject<number>();

// Подписчик А
mySubject$.subscribe(val => console.log('Подписчик А получил:', val));

// Отправляем данные
mySubject$.next(1);
mySubject$.next(2);

// Подписчик Б (подписался позже)
mySubject$.subscribe(val => console.log('Подписчик Б получил:', val));

// Эти данные получат оба подписчика
mySubject$.next(3);

// Вывод в консоли:
// Подписчик А получил: 1
// Подписчик А получил: 2
// Подписчик А получил: 3
// Подписчик Б получил: 3
```

<br/>

## <a name="behavior-reply-async"></a>В чем разница между BehaviorSubject, ReplySubject и AsyncSubject?

<br>

### Сравнительная таблица видов Subject

| Тип Subject | Хранит значения? | Начальное значение | Когда отдает данные? | Применение |
| :--- | :--- | :--- | :--- | :--- |
| **`Subject`** | Нет | Нет | Только новые события после подписки. | Простые события: клики, уведомления. |
| **`BehaviorSubject`** | Последнее (1) | **Да (обязательно)** | Сразу последнее значение при подписке. | Состояние (Store), данные пользователя. |
| **`ReplaySubject`** | Буфер из **N** | Нет | Всю историю из буфера при подписке. | Логи, история чата, кэш событий. |
| **`AsyncSubject`** | Последнее (1) | Нет | **Только после `.complete()`**. | Задачи с одним финальным результатом. |

---

### Подробный разбор видов

#### 1. BehaviorSubject
Хранит текущее значение. При подписке новый Observer сразу же получает последнее состояние.
* **Синхронность**: Можно получить значение без подписки через `subject.value`.
* **Пример**:
  ```typescript
  const theme$ = new BehaviorSubject<'light' | 'dark'>('light');
  theme$.subscribe(console.log); // Сразу выведет: 'light'
  theme$.next('dark');           // Выведет: 'dark'
  ```

<br>

**ReplySubject**

У ReplySubject принцип действия похож на BehaviorSubject. Отличие в том, что ReplySubject может хранить несколько значений и передавать их новый Observer'ам. При создании ReplySubject необходимо указать количество последних значений, которое он должен запоминать. Кроме этого мы можем задать время в миллисекундах, которое определяет насколько "старым" может быть значение.

`ReplaySubject` запоминает указанное количество последних значений и передает их новому подписчику, даже если он подписался намного позже.

```typescript
import { ReplaySubject } from 'rxjs';

// Создаем ReplaySubject с размером буфера 2
const history$ = new ReplaySubject<string>(2); 

history$.next('Post 1');
history$.next('Post 2');
history$.next('Post 3');

// На момент подписки в буфере лежат 'Post 2' и 'Post 3'
// 'Post 1' уже вытеснен из памяти, так как размер буфера всего 2
history$.subscribe(val => {
  console.log('Подписчик получил:', val);
});

// Вывод в консоли:
// Подписчик получил: Post 2
// Подписчик получил: Post 3
```

<br>

**AsyncSubject**

### Пример использования AsyncSubject

**AsyncSubject** — это вариант Subject, который выдает подписчикам только последнее значение и только в тот момент, когда поток полностью завершается (вызывается метод `.complete()`).

```typescript
import { AsyncSubject } from 'rxjs';

// Создаем поток для хранения результата вычислений
const calc$ = new AsyncSubject<number>();

// Эти значения записываются во внутреннюю переменную Subject.
// Подписчики их не увидят, так как поток еще не завершен.
calc$.next(10);
calc$.next(42);

// Оформляем подписку
calc$.subscribe(val => {
  console.log('Результат вычисления:', val);
});

console.log('Подписка оформлена, но в консоли пока пусто...');

// Только после вызова complete() последнее переданное значение (42) 
// будет разослано всем подписчикам.
calc$.complete(); 

/**
 * Вывод в консоли:
 * 1. Подписка оформлена, но в консоли пока пусто...
 * 2. Результат вычисления: 42
 */
```

<br/>

## <a name="higher-order"></a>Что такое Observable высшего порядка (Higher-Order)?

**Observable высшего порядка** — это поток, который испускает другие потоки (Observable) вместо обычных значений (чисел, строк или объектов).

Представьте это как «матрешку»: основной поток при каждом событии создает новый независимый поток. Чтобы работать с данными из этих внутренних потоков, используются специальные операторы трансформации.

---

### Проблема «потока в потоке»

Если вы попытаетесь использовать обычный `map` для вызова API внутри потока, вы получите структуру типа `Observable<Observable<T>>`.

```typescript
// Проблема:
source$.pipe(
  map(id => this.http.get(`/api/user/${id}`)) 
).subscribe(innerObservable => {
  // Чтобы получить данные пользователя, пришлось бы подписываться ВНУТРИ подписки
  innerObservable.subscribe(user => console.log(user)); // Плохая практика!
});
```

### Операторы высшего порядка (Flattening Operators)

Чтобы избежать «ада подписок» (**nested subscriptions**), используются операторы, которые автоматически подписываются на внутренний Observable и передают его значения в основной поток. Этот процесс называется **Flattening** (сплющивание).

| Оператор | Назначение |
| :--- | :--- |
| **`switchMap`** | Переключается на новый поток, отменяя подписку на предыдущий. |
| **`mergeMap`** | Подписывается на все внутренние потоки и выдает их значения параллельно. |
| **`concatMap`** | Ставит потоки в очередь: подписывается на следующий только после завершения текущего. |
| **`exhaustMap`** | Игнорирует новые входящие потоки, пока текущий внутренний поток не завершится. |

<br/>

## <a name="of-from"></a>В чем разница между of и from?

Допустим у нас есть массив:

Оператор **`from`** преобразует различные структуры данных (массивы, итерируемые объекты, промисы) в поток Observable, последовательно выдавая их содержимое.

```typescript
import { from } from 'rxjs';

/**
 * 1. Работа с массивом
 * Разворачивает массив и эмитит каждый элемент по отдельности.
 */
const fruits = ["orange", "apple", "banana"];

from(fruits).subscribe(val => console.log('Фрукт:', val));
// Вывод:
// 'orange'
// 'apple'
// 'banana'


/**
 * 2. Работа с Promise
 * Превращает Promise в Observable: дожидается завершения (resolve) 
 * и эмитит полученный результат.
 */
const promiseSource = fetch('[https://api.example.com/data](https://api.example.com/data)');

from(promiseSource).subscribe({
  next: (response) => console.log('Ответ сервера получен:', response),
  error: (err) => console.error('Ошибка запроса:', err)
});
```

### 1. Оператор `of`
Создает поток из переданных аргументов «как есть». Он просто берет каждое значение и эмитит его.

```javascript
import { of } from 'rxjs';

const fruits = ["orange", "apple", "banana"];

// Вернет один эмит: сам массив целиком
of(fruits).subscribe(console.log); 
// Результат: ["orange", "apple", "banana"]

// Чтобы получить значения по отдельности, нужно использовать spread-оператор
of(...fruits).subscribe(console.log); 
// Результат: 'orange', 'apple', 'banana'
```

<br/>

## <a name="multicasting"></a>Что такое Multicasting?

**Мультикастинг** — это процесс передачи данных от одного источника сразу нескольким подписчикам (Observer) в рамках одного и того же выполнения.

### Как это работает
В RxJS по умолчанию обычные Observable являются **Unicast** (одноадресными). Это значит, что если Observable делает HTTP-запрос, то при наличии трех подписчиков будет сделано три независимых HTTP-запроса. 

**Multicasting** позволяет оптимизировать этот процесс: источник выполняется один раз, а данные «расшариваются» между всеми активными слушателями.

---

### Пример использования через Subject
`Subject` — это самый простой способ реализовать мультикастинг, так как он внутри себя хранит список подписчиков.

```typescript
import { Subject } from "rxjs";

const subject = new Subject<number>();

// Подписываем несколько слушателей
subject.subscribe(v => console.log(`observerA: ${v}`));
subject.subscribe(v => console.log(`observerB: ${v}`));

// Одно действие (next) уведомляет всех сразу
subject.next(1);
subject.next(2);

/**
 * Вывод в консоли:
 * observerA: 1
 * observerB: 1
 * observerA: 2
 * observerB: 2
 */
```

<br/>

## <a name="stream"></a>Что такое поток (stream) в RxJS?

**Поток (Stream)** в RxJS — это последовательность событий, упорядоченных во времени. Если массив — это набор данных в пространстве (памяти), то поток — это набор данных во времени.

### Метафора конвейера
Представьте **конвейерную ленту**:
* **Элементы** на ленте — это данные (клики, ответы от сервера, значения из инпута).
* **Лента** постоянно движется (время идет).
* **Рабочие** вдоль ленты — это операторы (`map`, `filter`), которые трансформируют или фильтруют элементы по одному, как только они до них доезжают.

---

### Из чего состоит поток?

Поток может транслировать три типа сигналов (событий):
1.  **Value**: Обычные данные (новое число, объект и т.д.).
2.  **Error**: Ошибка, после которой поток завершается.
3.  **Complete**: Сигнал о том, что поток успешно закончен и данных больше не будет.

---

### Ключевые свойства потока

| Свойство | Описание |
| :--- | :--- |
| **Асинхронность** | Поток может выдать значение в любой момент времени. |
| **Непрерывность** | Мы не знаем, когда придет следующее значение, но мы «слушаем» канал. |
| **Декларативность** | Мы описываем, *что* должно произойти с данными (через операторы), а не *как* их итерировать. |

---

### Пример потока в коде

```typescript
import { fromEvent } from 'rxjs';
import { map, filter } from 'rxjs/operators';

// Создаем поток из кликов по документу
const clicks$ = fromEvent(document, 'click');

// Обрабатываем поток на конвейере
clicks$.pipe(
  map(event => (event as MouseEvent).clientX), // Берем координату X
  filter(x => x > 100)                         // Пропускаем только если X > 100
).subscribe(x => console.log(`Клик в точке: ${x}`));
```
<br/>

## <a name="fork-join-combine-latest"></a>В чем разница между операторами combineLatest и forkJoin?

Оба оператора используются для объединения нескольких Observable в один, но они работают по принципиально разным сценариям: один ждет финала, а другой следит за изменениями в реальном времени.

---

### 1. forkJoin
Работает аналогично `Promise.all`. Он ждет, пока **все** входящие потоки завершатся (**complete**), и только тогда выдает массив их последних значений.

* **Когда срабатывает:** Один раз за всё время.
* **Условие:** Если хотя бы один поток бесконечен (не вызывает `complete`), `forkJoin` ничего не выдаст.
* **Применение:** Групповые HTTP-запросы, где результат нужен только тогда, когда получены все ответы.

---

### 2. combineLatest
Следит за всеми потоками одновременно. Он выдает массив значений, как только **каждый** из потоков испустит хотя бы по одному значению. После этого он делает новый эмит при **любом** изменении в любом из входящих потоков.

* **Когда срабатывает:** Первый раз — когда у всех есть по 1 значению. Далее — на каждый `next()`.
* **Условие:** Не ждет завершения потоков.
* **Применение:** Синхронизация состояний (например, вычисление итоговой цены: `Цена` × `Количество` × `Скидка`).

---

### Сравнительная таблица

| Характеристика | `forkJoin` | `combineLatest` |
| :--- | :--- | :--- |
| **Когда выдает результат** | После `complete` всех потоков. | Как только у каждого есть по 1 значению. |
| **Количество эмитов** | Ровно один. | Многократно (при каждом обновлении). |
| **Если один поток "завис"** | Ждет вечно. | Ждет первого значения, потом работает. |
| **Результат** | Только финальные значения. | Всегда самые актуальные значения. |

---

### Пример в коде (RxJS 7+)

```typescript
import { of, forkJoin, combineLatest, timer } from 'rxjs';
import { take } from 'rxjs/operators';

const streamA$ = of('A'); 
const streamB$ = timer(1000, 1000).pipe(take(2)); // Выдаст 0 через 1с, затем 1 через 2с

// forkJoin: Ждет 2 секунды и выдает финальный результат
forkJoin([streamA$, streamB$]).subscribe(val => console.log('forkJoin:', val));
// Результат через 2 сек: ['A', 1]

// combineLatest: Сработает дважды
combineLatest([streamA$, streamB$]).subscribe(val => console.log('combineLatest:', val));
// Через 1 сек: ['A', 0]
// Через 2 сек: ['A', 1]
```

<br/>

## <a name="zip-combineLatest-withLatestFrom"></a>Операторы объединения: zip, combineLatest и withLatestFrom

В RxJS существует несколько способов объединить данные из разных потоков. Выбор оператора зависит от того, какое событие должно инициировать выброс данных и какие значения важны.
### 1. zip (Попарное соответствие)
Он объединяет значения потоков строго по их индексу: первое с первым, второе со вторым.
Логика: Ждет, пока у каждого входящего потока появится значение с соответствующим порядковым номером.
Когда использовать: Когда вам нужно сопоставить данные из разных источников, которые логически связаны по порядку (например, массив имен и массив ID).

```ts
import { zip, of } from 'rxjs';
import { map } from 'rxjs/operators';

let age$ = of(27, 25, 29);
let name$ = of('Foo', 'Bar', 'Beer');
let isDev$ = of(true, true, false);

zip(age$, name$, isDev$).pipe(
  map(([age, name, isDev]) => ({ age, name, isDev })),
)
.subscribe(x => console.log(x));

// Результат:
// { age: 27, name: 'Foo', isDev: true }
// { age: 25, name: 'Bar', isDev: true }
// { age: 29, name: 'Beer', isDev: false }
```

### 2. combineLatest (Синхронизация состояний)

Выдает комбинацию последних значений из каждого потока.

Логика: Срабатывает впервые, когда каждый поток выдал хотя бы одно значение. Далее срабатывает при любом изменении в любом из потоков.

Когда использовать: Когда результат зависит от суммы нескольких состояний (например, фильтрация списка, где учитывается и текст поиска, и выбранная категория).

```ts
import { combineLatest, of } from 'rxjs';
import { delay, startWith } from 'rxjs/operators';

const observables = [1, 5, 10].map(
  n => of(n).pipe(
    delay(n * 1000),   
    startWith(0),
  )
);

combineLatest(observables).subscribe(value => console.log(value));

// Логи:
// [0, 0, 0] — сразу (благодаря startWith)
// [1, 0, 0] — через 1 сек (изменился 1-й поток)
// [1, 5, 0] — через 5 сек (изменился 2-й поток)
// [1, 5, 10] — через 10 сек (изменился 3-й поток)

```
### 3. withLatestFrom (Главный и помощники)
Позволяет основному потоку «заглянуть» в другие потоки и забрать их последние значения в момент своего выброса.

Логика: Эмит происходит только тогда, когда эмитит источник (source). Вспомогательные потоки сами по себе не вызывают срабатывания.

Когда использовать: Когда событие (например, клик «Сохранить») должно собрать данные из других источников (например, текущие значения полей формы).

```ts
import { fromEvent, interval } from 'rxjs';
import { withLatestFrom } from 'rxjs/operators';

const clicks = fromEvent(document, 'click');
const timer = interval(1000);

// Срабатывает ТОЛЬКО при клике. 
// В момент клика берет последнее значение из таймера.
const result = clicks.pipe(withLatestFrom(timer));

result.subscribe(x => console.log(x));
// Вывод: [MouseEvent, 4] (если кликнули на 5-й секунде)
```

<br/>

## <a name="some-frequently-used-RxJS-operators"></a>Какие операторы RxJS используются чаще всего?
RxJS предоставляет богатый набор операторов, которые помогают манипулировать данными, фильтровать их и комбинировать Observable. Вот наиболее распространенные из них:
Список ключевых операторов
* **map:** Трансформирует значения, исходящие от источника.
  ```ts
  observable.pipe(map(value => value * 2));
  ```
* **filter:** Отфильтровывает значения, которые не соответствуют заданному условию.
  ```ts
 observable.pipe(filter(value => value > 10));
  ```

* **mergeMap:** "Сплющивает" вложенные Observable и испускает их значения (выполняет запросы параллельно).
  ```ts
 observable.pipe(mergeMap(value => fetchData(value)));
  ```

* **switchMap:** Отменяет любой предыдущий внутренний Observable, когда испускается новое значение (удобно для поиска).
  ```ts
 observable.pipe(switchMap(value => fetchData(value)));
  ```

* **catchError:** Перехватывает ошибки в потоке и позволяет обработать их или вернуть запасные данные (fallback), чтобы поток не прервался.
  ```ts
 observable.pipe(catchError(err => of('Обнаружена ошибка')));
  ```

* **debounceTime:** Вводит задержку перед испусканием значений. Чаще всего используется для обработки ввода в текстовых полях, чтобы не спамить запросами.
  ```ts
 observable.pipe(debounceTime(300));
  ```



<br/>
<br/>

<hr/>
